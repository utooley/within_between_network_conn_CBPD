---
title: "CBPD Parcel-Level Restuls"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(stats)
library(parallel)
library(lm.beta)
library(packrat)
library(summarytools)
library(visreg)
library(mgcv)
library(RLRsim)
library(GGally)
library(stringr)
library(tidyverse)
library(data.table)
library(bigmemory)
library(biglm)
#load the .RDS file
pipeline='nogsr_spkreg_fd0.5dvars1.75_drpvls'
pipeline="nogsr_spkreg_fd1.25dvars2_drpvls"
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)

load(paste0(network_dir,"/CBPD_n90_schaefer400_allruns.Rdata"))
```

## Load data
```{r load parcel data, include=FALSE, echo=FALSE}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#make a huge dataframe of subjects x edges

#files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
# vect <- matrix(nrow = dim(main_unique)[1], ncol = 79801)
# for (i in 1:dim(main_unique)[1]){
# mat <- data.frame(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
# vect[i,2:79801]<-mat[lower.tri(mat)] #read out the lower triangle from matrix by row
# }

#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
# goback <- matrix(nrow = 400, ncol=400)
# goback[lower.tri(goback, diag=FALSE)] <- vec
# goback <- t(goback)
# goback

#saveRDS(vect,"~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rdata")

#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
```

## Run edgwise linear models
Run linear models on edges, controlling for age, sex and average motion.
```{r edgewise linear models}
# edgewise_age_pvals<- apply(n90_all_edges,2, function(x) { summary(lm(x~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$pctVolsCensored+main_unique$totalSizet))$coef[2,4]}) #without multicore

#multi-core apply the linear model across the matrix of edges, get age pvals 
# edgewise_age_pvals<- mclapply(1:79800, function(x) { summary(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg))$coef[2,4]}, mc.cores = 4)
# edgewise_age_pvals <- unlist(edgewise_age_pvals)
# edgewise_age_pvals_fdr <- cbind(edgewise_age_pvals,p.adjust(edgewise_age_pvals,method = "fdr"))
# #get age betas
# edgewise_age_betas<- mclapply(1:79800, function(x) { lm.beta(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg))$standardized.coefficients[[2]]}, mc.cores = 4)
# edgewise_age_betas <- unlist(edgewise_age_betas)
#save for reloading in future
save(edgewise_age_pvals_fdr, edgewise_age_betas,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]
edge_age_betas_mat <- matrix(nrow = 400, ncol=400)
edge_age_betas_mat[lower.tri(edge_age_betas_mat, diag=FALSE)] <- edgewise_age_betas
edge_age_betas_mat[upper.tri( edge_age_betas_mat)] <- t(edge_age_betas_mat)[upper.tri( edge_age_betas_mat)]
```

## Make a chord diagram of pvals and betas

```{r chord diagram of edges, include=FALSE, echo=FALSE}
library(circlize)
library(car)
library(dplyr)
#read in node identity and order
community_assign <- read.delim("~/Documents/tools/parcellations/schaefer400x7CommunityAffiliation.1D", header = F)
communities <- paste0("comm",community_assign$V1) %>% car::recode(.,"'comm1'='Visual'; 'comm2'='Somatomotor' ; 'comm3'='Dorsal Attention';'comm4'='Ventral Attention';'comm5'='Limbic';'comm6'='Frontoparietal';'comm7'='Default'")

#just threshold the betas
links_to_show=edge_age_pvals_mat<= 0.001;edge_age_betas_mat[links_to_show==FALSE] <- 0
#how stringently you threshold determines when you hit the memory limit, 400x400 won't show at 0.005.
col_fun = colorRamp2(breaks = c(-0.48,-0.25, 0,0.25, 0.5),
                  colors = c("blue", "white","white","white", "red"),
                  transparency = .5)
#adding rownames and colnames makes the graph weird.
rownames(edge_age_betas_mat) <- communities;colnames(edge_age_betas_mat) <- communities
par(cex = 1.5)
chordDiagramFromMatrix(edge_age_betas_mat[1:400,1:400], annotationTrack = c("name","grid"),
             symmetric = TRUE,grid.col = c("#7B287E", "#5CA1C8", "#0A9045","#C33AF8","#dcf8a4", "#EF9C23", "#E34A53"), col=col_fun, reduce = -1) #reduce keeps even the tiny grids, keeps from eliminating some sectors, annotationTrack turns off the tick marks

# circos.par(gap.after = c(rep(1, nrow(edge_age_pvals_mat)-1), 15, rep(1, ncol(edge_age_pvals_mat)-1), 15)) try and make gap between nodes smaller

```

## Plot parcelwise on brain at different sig thresholds

```{r get nodes to plot, include=FALSE, echo=FALSE}
#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[1,] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat <- t(edge_age_pvals_mat)
```

## Plot pvals on brain.
```{r brain plotting setup, include=FALSE, echo=FALSE}
library(fsbrain) #this may not work if you're editing the script directly on the cluster...
library(freesurferformats)
#rearrange the order of the brains in the T9 view of fsbrain
source("~/Documents/tools/fsbrain_fix_t9.R")
environment(brainview.t9) <- asNamespace('fsbrain')
assignInNamespace("brainview.t9", brainview.t9, ns = "fsbrain")
subjects_dir = "/Users/utooley/Documents/tools/CBIG/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/FreeSurfer5.3/";
subject_id = 'fsaverage';       # for functions which use one subject only
atlas='Schaefer2018_400Parcels_7Networks_order'

#Get the Schaefer atlas region names
schaefer_atlas_region_names_lh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="lh");
schaefer_atlas_region_names_rh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="rh");

#set output dir for saving images
output_image_directory="~/Documents/projects/in_progress/within_between_network_conn_CBPD/output/figures/brains/"
  
#Set RGL defaults, larger window and how to make snapshots!
rgloptions=list("windowRect"=c(50,50,1000,1000));
```


```{r brain plotting initial, include=FALSE, echo=FALSE}
#Use different pval thresholds and plot parcels that have age-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
values <- values/2 #because we indexed the full matrix, there are duplicates for each edge
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","blue"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#Show with the community colors
#Create a list from the vector of Schaefer structure names and the labels from WSBM consensus partition
comms_and_edges=ifelse(values==0,community_assign$V1,-values) #where there are sig age effects, overwrite community color assignment
num_of_sig_age_edges_lh=as.list(setNames(c(0, comms_and_edges[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, comms_and_edges[201:400]), schaefer_atlas_region_names_rh))

#plot with colors of communities
yeo_colors=colorRampPalette(c("#000000","#000000","#A9A9A9", "#7B287E", "#5CA1C8", "#0A9045","#C33AF8", "#dcf8a4", "#EF9C23", "#E34A53"))
makecmap_options=list('colFn'=yeo_colors)

rgloptions=list("windowRect"=c(50,50,1000,1000));
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"community_colors.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
#just plot schaefer communities
rglactions=list("snapshot_png"=paste0(output_image_directory,"community_colors.png"))
vis.subject.annot(subjects_dir, 'fsaverage6','Schaefer2018_400Parcels_7Networks_order','both', "inflated", views="t4",
                  rgloptions = rgloptions,rglactions = rglactions)
```

## Non-linear effects across edges

Where are there non-linear effects of age, if anywhere.
```{r edgewise gam models}
library(mgcv)
library(RLRsim)
library(parallel)
#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
#read back in subject data
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)
load(paste0(network_dir,"/CBPD_n90_schaefer400_allruns.Rdata"))

#multi-core apply the exactRLRT test for non-linear model across the matrix of edges, get age non-lin pvals 
# edgewise_age_nonlin_pvals<- mclapply(1:79800, function(x) {exactRLRT(gamm(n90_all_edges[,x]~s(main_unique$age_scan)+main_unique$male+main_unique$fd_mean_avg, method = "REML")$lme)$p.value}, mc.cores = 4)
# edgewise_age_nonlin_pvals <- unlist(edgewise_age_nonlin_pvals)
#save for reloading in future
save(edgewise_age_nonlin_pvals,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_nonlin_pvals #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices[1:(dim(indices)[1]/2),])) #for each parcel, how many age-significant edges does it have at a given pval thresh--indices gives duplicates!
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","orange", "red"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_nonlin_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#What do these edges look like pattern-wise?
sum(edgewise_age_nonlin_pvals<0.05)/length(edgewise_age_nonlin_pvals) #percentage
which(edgewise_age_nonlin_pvals<0.00001)
#make a big plot of them
par(mfrow=c(5,5))
lapply(which(edgewise_age_nonlin_pvals<0.00001), function(x) {plot(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg, method = "REML"), residuals=T);summary(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg, method = "REML"))})
```

## Are these long or short-distance edges?

First, need to compute the distance matrix for Schaefer400 (distances between centroids), then can sort out significant edges based on distance.

## Compare cosine similarity across significance levels for nodes

Need to use Rick's Matlab code to make null models. Or use some kind of null model--maybe first just use different random pairs of parcels.

Also--would do this on the average matrix (Do I already have this on the cluster? If not, make it), and not the subject matrices? Seems like so.
For a given significance level, take the sig parcels and compute cosine similarity between pairs of connectivity profiles->mean or distribution
Then, compare that to consine similarity between those same pairs of parcels but on randomized null networks generated using Rick's code, or to random pairs of parcels as a less stringent test.
```{r make average FC matrix}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#get adj matrix files
files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
#make an average matrix
summed=matrix(0,400,400)
for (i in 1:dim(main_unique)[1]){
mat <- as.matrix(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
summed<- summed+mat
}
average <- summed/dim(main_unique)[1]
#save for reloading in future
write.csv(average,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv", row.names = F)
```


```{r cosine similarity between significant age nodes}
library(lsa) #for cosine similarity
#read in average matrix
average_FC_mat <- as.matrix(read.csv("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv"))
#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
sig_parcel_cosine=vector()
#skip 0.01 for now, because it's really big
pvalues=c(0.001,0.0001,0.00001)
for (pvalue in pvalues){
  i=1
  sig_parcel_cosine=vector()
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
for (x in indices[,1]){
  for (y in indices[,2]){
    sig_parcel_cosine[i] <- print(cosine(average_FC_mat[,x], average_FC_mat[,y]))#take both columns
    i <- i+1
  }
}
assign(paste0("sig_parcel_",pvalue,"cosine"), sig_parcel_cosine[sig_parcel_cosine!=1]) #each cosine value has a duplicate?
}
sig_parcel_0.0001cosine <- `sig_parcel_1e-04cosine`
sig_parcel_0.00001cosine <- `sig_parcel_1e-05cosine`
save(sig_parcel_0.001cosine, sig_parcel_0.0001cosine, sig_parcel_0.00001cosine, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_data.Rdata")

#null model
indicesx=random_sample(1:400);indicesy=random(1:400)
random_parcels[i] <- cosine similarity(average_FC_mat[x_vector], average_FC_mat[y_vector])

#plot the difference

l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","orange", "red"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_nonlin_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}
```
#get SA and run same models across parcels.