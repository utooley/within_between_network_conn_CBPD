---
title: "CBPD Parcel-Level Restuls"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(stats)
library(parallel)
library(lm.beta)
library(packrat)
library(summarytools)
library(visreg)
library(mgcv)
library(RLRsim)
library(GGally)
library(stringr)
library(tidyverse)
library(data.table)
library(bigmemory)
library(biglm)
#load the .RDS file
pipeline='nogsr_spkreg_fd0.5dvars1.75_drpvls'
pipeline="nogsr_spkreg_fd1.25dvars2_drpvls"
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)

load(paste0(network_dir,"/CBPD_n90_schaefer400_allruns.Rdata"))
```

## Load data
```{r load parcel data, include=FALSE, echo=FALSE}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#make a huge dataframe of subjects x edges

#files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
# vect <- matrix(nrow = dim(main_unique)[1], ncol = 79801)
# for (i in 1:dim(main_unique)[1]){
# mat <- data.frame(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
# vect[i,2:79801]<-mat[lower.tri(mat)] #read out the lower triangle from matrix by row
# }

#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
# goback <- matrix(nrow = 400, ncol=400)
# goback[lower.tri(goback, diag=FALSE)] <- vec
# goback <- t(goback)
# goback

#saveRDS(vect,"~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rdata")

#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
```

## Run edgwise linear models
Run linear models on edges, controlling for age, sex and average motion.
```{r edgewise linear models}
# edgewise_age_pvals<- apply(n90_all_edges,2, function(x) { summary(lm(x~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$pctVolsCensored+main_unique$totalSizet))$coef[2,4]}) #without multicore

#multi-core apply the linear model across the matrix of edges, get age pvals 
# edgewise_age_pvals<- mclapply(1:79800, function(x) { summary(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg))$coef[2,4]}, mc.cores = 4)
# edgewise_age_pvals <- unlist(edgewise_age_pvals)
# edgewise_age_pvals_fdr <- cbind(edgewise_age_pvals,p.adjust(edgewise_age_pvals,method = "fdr"))
# #get age betas
# edgewise_age_betas<- mclapply(1:79800, function(x) { lm.beta(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg))$standardized.coefficients[[2]]}, mc.cores = 4)
# edgewise_age_betas <- unlist(edgewise_age_betas)
#save for reloading in future
save(edgewise_age_pvals_fdr, edgewise_age_betas,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]
edge_age_betas_mat <- matrix(nrow = 400, ncol=400)
edge_age_betas_mat[lower.tri(edge_age_betas_mat, diag=FALSE)] <- edgewise_age_betas
edge_age_betas_mat[upper.tri( edge_age_betas_mat)] <- t(edge_age_betas_mat)[upper.tri( edge_age_betas_mat)]
```

## Make a chord diagram of pvals and betas

```{r chord diagram of edges, include=FALSE, echo=FALSE}
library(circlize)
library(car)
library(dplyr)
#read in node identity and order
community_assign <- read.delim("~/Documents/tools/parcellations/schaefer400x7CommunityAffiliation.1D", header = F)
communities <- paste0("comm",community_assign$V1) %>% car::recode(.,"'comm1'='Visual'; 'comm2'='Somatomotor' ; 'comm3'='Dorsal Attention';'comm4'='Ventral Attention';'comm5'='Limbic';'comm6'='Frontoparietal';'comm7'='Default'")

#just threshold the betas
links_to_show=edge_age_pvals_mat<= 0.001;edge_age_betas_mat[links_to_show==FALSE] <- 0
#how stringently you threshold determines when you hit the memory limit, 400x400 won't show at 0.005.
col_fun = colorRamp2(breaks = c(-0.48,-0.25, 0,0.25, 0.5),
                  colors = c("blue", "white","white","white", "red"),
                  transparency = .5)
#adding rownames and colnames makes the graph weird.
rownames(edge_age_betas_mat) <- communities;colnames(edge_age_betas_mat) <- communities
par(cex = 1.5)
chordDiagramFromMatrix(edge_age_betas_mat[1:400,1:400], annotationTrack = c("name","grid"),
             symmetric = TRUE,grid.col = c("#7B287E", "#5CA1C8", "#0A9045","#C33AF8","#dcf8a4", "#EF9C23", "#E34A53"), col=col_fun, reduce = -1) #reduce keeps even the tiny grids, keeps from eliminating some sectors, annotationTrack turns off the tick marks

# circos.par(gap.after = c(rep(1, nrow(edge_age_pvals_mat)-1), 15, rep(1, ncol(edge_age_pvals_mat)-1), 15)) try and make gap between nodes smaller

```

## Plot parcelwise on brain at different sig thresholds

```{r get nodes to plot, include=FALSE, echo=FALSE}
#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[1,] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat <- t(edge_age_pvals_mat)
```

## Plot pvals on brain.
```{r brain plotting setup, include=FALSE, echo=FALSE}
library(fsbrain) #this may not work if you're editing the script directly on the cluster...
library(freesurferformats)
#rearrange the order of the brains in the T9 view of fsbrain
source("~/Documents/tools/fsbrain_fix_t9.R")
environment(brainview.t9) <- asNamespace('fsbrain')
assignInNamespace("brainview.t9", brainview.t9, ns = "fsbrain")
subjects_dir = "/Users/utooley/Documents/tools/CBIG/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/FreeSurfer5.3/";
subject_id = 'fsaverage';       # for functions which use one subject only
atlas='Schaefer2018_400Parcels_7Networks_order'

#Get the Schaefer atlas region names
schaefer_atlas_region_names_lh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="lh");
schaefer_atlas_region_names_rh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="rh");

#set output dir for saving images
output_image_directory="~/Documents/projects/in_progress/within_between_network_conn_CBPD/output/figures/brains/"
  
#Set RGL defaults, larger window and how to make snapshots!
rgloptions=list("windowRect"=c(50,50,1000,1000));
```


```{r brain plotting initial, include=FALSE, echo=FALSE}
#Use different pval thresholds and plot parcels that have age-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
values <- values/2 #because we indexed the full matrix, there are duplicates for each edge
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","blue"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#Show with the community colors
#Create a list from the vector of Schaefer structure names and the labels from WSBM consensus partition
comms_and_edges=ifelse(values==0,community_assign$V1,-values) #where there are sig age effects, overwrite community color assignment
num_of_sig_age_edges_lh=as.list(setNames(c(0, comms_and_edges[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, comms_and_edges[201:400]), schaefer_atlas_region_names_rh))

#plot with colors of communities
yeo_colors=colorRampPalette(c("#000000","#000000","#A9A9A9", "#7B287E", "#5CA1C8", "#0A9045","#C33AF8", "#dcf8a4", "#EF9C23", "#E34A53"))
makecmap_options=list('colFn'=yeo_colors)

rgloptions=list("windowRect"=c(50,50,1000,1000));
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"community_colors.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
#just plot schaefer communities
rglactions=list("snapshot_png"=paste0(output_image_directory,"community_colors.png"))
vis.subject.annot(subjects_dir, 'fsaverage6','Schaefer2018_400Parcels_7Networks_order','both', "inflated", views="t4",
                  rgloptions = rgloptions,rglactions = rglactions)
```

## Non-linear effects across edges

Where are there non-linear effects of age, if anywhere.
```{r edgewise gam models}
library(mgcv)
library(RLRsim)
library(parallel)
#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
#read back in subject data
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)
load(paste0(network_dir,"/CBPD_n90_schaefer400_allruns.Rdata"))

#multi-core apply the exactRLRT test for non-linear model across the matrix of edges, get age non-lin pvals 
# edgewise_age_nonlin_pvals<- mclapply(1:79800, function(x) {exactRLRT(gamm(n90_all_edges[,x]~s(main_unique$age_scan)+main_unique$male+main_unique$fd_mean_avg, method = "REML")$lme)$p.value}, mc.cores = 4)
# edgewise_age_nonlin_pvals <- unlist(edgewise_age_nonlin_pvals)
#save for reloading in future
save(edgewise_age_nonlin_pvals,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_nonlin_pvals #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices[1:(dim(indices)[1]/2),])) #for each parcel, how many age-significant edges does it have at a given pval thresh--indices gives duplicates!
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","orange", "red"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_nonlin_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#What do these edges look like pattern-wise?
sum(edgewise_age_nonlin_pvals<0.05)/length(edgewise_age_nonlin_pvals) #percentage
which(edgewise_age_nonlin_pvals<0.00001)
#make a big plot of them
par(mfrow=c(5,5))
lapply(which(edgewise_age_nonlin_pvals<0.00001), function(x) {plot(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg, method = "REML"), residuals=T);summary(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg, method = "REML"))})
```

## Are these long or short-distance edges?

First, need to compute the distance matrix for Schaefer400 (distances between centroids), then can sort out significant edges based on distance.

## Compare cosine similarity across significance levels for nodes

Need to use Rick's Matlab code to make null models. Or use some kind of null model--maybe first just use different random pairs of parcels.

Also--would do this on the average matrix (Do I already have this on the cluster? If not, make it), and not the subject matrices? Seems like so.
For a given significance level, take the sig parcels and compute cosine similarity between pairs of connectivity profiles->mean or distribution
Then, compare that to consine similarity between those same pairs of parcels but on randomized null networks generated using Rick's code, or to random pairs of parcels as a less stringent test.
```{r make average FC matrix}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#get adj matrix files
files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
#make an average matrix
summed=matrix(0,400,400)
for (i in 1:dim(main_unique)[1]){
mat <- as.matrix(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
summed<- summed+mat
}
average <- summed/dim(main_unique)[1]
#save for reloading in future
write.csv(average,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv", row.names = F)
```


```{r cosine similarity between significant age nodes, first with all edges, then only significant edges}
library(lsa) #for cosine similarity
#read in average matrix
average_FC_mat <- as.matrix(read.csv("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv"))
#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects.Rdata")
#make a matrix
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400);edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
sig_parcel_cosine=vector()
#skip 0.01 for now, because it's really big
pvalues=c(0.001,0.0001,0.00001)
for (pvalue in pvalues){
  #i=1
  sig_parcel_cosine=vector()
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects below a pval
for (x in 1:dim(indices)[1]){
  #for (y in indices[,2]){
    sig_parcel_cosine[x] <- cosine(average_FC_mat[,as.numeric(indices[x,1])], average_FC_mat[,as.numeric(indices[x,2])])#take both columns
    #i <- i+1
  #}
}
assign(paste0("sig_parcel_",pvalue,"cosine"), sig_parcel_cosine[sig_parcel_cosine!=1]) #each cosine value has a duplicate?
}
sig_parcel_edges_only_0.001cosine <- sig_parcel_0.001cosine
sig_parcel_edges_only_0.0001cosine <- `sig_parcel_1e-04cosine`
sig_parcel_edges_only_0.00001cosine <- `sig_parcel_1e-05cosine`
save(sig_parcel_edges_only_0.001cosine, sig_parcel_edges_only_0.0001cosine, sig_parcel_edges_only_0.00001cosine, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_edges_only_data.Rdata")
load(file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_data.Rdata")

null_parcel_cosine=vector()
pvalues=c(0.001,0.0001,0.00001)
for (pvalue in pvalues){
  i=1
  null_parcel_cosine=vector()
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
indices[,1] <- sample(1:400,dim(indices)[1], replace = T)#replace with random integers 1-400
indices[,2] <- sample(1:400,dim(indices)[1], replace = T)#replace with random integers 1-400
for (x in 1:dim(indices)[1]){
  #for (y in indices[,2]){
    #null_parcel_cosine[i] <- print(cosine(average_FC_mat[,x], average_FC_mat[,y]))#take both columns
    null_parcel_cosine[x] <- cosine(average_FC_mat[,as.numeric(indices[x,1])], average_FC_mat[,as.numeric(indices[x,2])])
    #i <- i+1
  #}
}
assign(paste0("null_parcel_",pvalue,"cosine"), null_parcel_cosine[null_parcel_cosine!=1]) #each cosine value has a duplicate?
}
null_parcel_edges_only_0.001cosine <- null_parcel_0.001cosine
null_parcel_edges_only_0.0001cosine <- `null_parcel_1e-04cosine`
null_parcel_edges_only_0.00001cosine <- `null_parcel_1e-05cosine`
save(null_parcel_edges_only_0.001cosine, null_parcel_edges_only_0.0001cosine, null_parcel_edges_only_0.00001cosine, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_null_edges_only_data.Rdata")

#plot the difference
pvalues=c(0.001,0.0001,0.00001)
j <- hist(null_parcel_edges_only_0.00001cosine)
l <- hist(sig_parcel_edges_only_0.00001cosine)
plot(j, col=rgb(0,0,1,1/4), xlim=c(-1,1))  # first histogram
plot(l, col=rgb(1,0,0,1/4), xlim=c(-1,1), add=T)
t.test(sig_parcel_0.00001cosine, null_parcel_0.00001cosine)
```

# Surface Area Models

```{r get average SA for each subject}
library(fsbrain)
library(freesurferformats)
subjects_list <- main_unique$ID
subjects_dir = "/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/"

#get mean thickness and area for these subjects
n90_average_wholebrain_data = group.multimorph.agg.native(subjects_dir, subjects_list, c("thickness", "area"),
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=mean,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_average_wholebrain_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_thickness_SA_n90.Rdata")
#load it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_thickness_SA_n90.Rdata")
#plot mean whole-brain with age
brain_data <- left_join(rename(n90_average_wholebrain_data, ID=subject_id), main_unique, by="ID") %>% mutate(mean_SA=(rh.area+lh.area)/2, mean_CT=(rh.thickness+lh.thickness)/2)
summary(lm(mean_SA~age_scan+male, data=brain_data))
summary(lm(mean_CT~age_scan+male, data=brain_data))
visreg(lm(mean_SA~age_scan+male, data=brain_data), main= "Surface Area")

#get raw SA
n90_total_SA_wholebrain_data = group.multimorph.agg.native(subjects_dir, subjects_list, "area",
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=sum,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_total_SA_wholebrain_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_SA_n90.Rdata")
#save it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_SA_n90.Rdata") 
n90_total_SA_wholebrain_data <- left_join(main_unique, mutate(n90_total_SA_wholebrain_data, total_SA=rh.area+lh.area), by="ID")
summary(lm(total_SA~age_scan+male, data=n90_total_SA_wholebrain_data))
visreg(lm(total_SA~age_scan+male, data=n90_total_SA_wholebrain_data), main= "Total Surface Area")
```

The R function in fsbrain called `group.agg.atlas.native` will do this with an annot file.
However, this function looks like it computes surface area within each parcel itself, based on the annotation file I wrote with mri_surf2surf, meaning that the mri_segstats I ran was not needed. 
These values don't match those generated by mri_segstats, though, maybe because of the --accumulate flag I used that weights each parcel by the # of voxels?

```{r get raw SA within Schaefer400 parcels for each subject}
subjects_list <- main_unique$ID[1:3]
#get mean thickness and area for these subjects--looks like this does it itself
n90_average_parcel_data = group.agg.atlas.native(subjects_dir, subjects_list,"area",
     "lh", 'Schaefer2018_400Parcels_7Networks_order', agg_fun=mean)

lh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/schaefer400_lh_surfarea_stats.txt") %>% rename(.,ID=lh.schaefer400_7nets.surfarea.area);rh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/schaefer400_rh_surfarea_stats.txt")%>% rename(.,ID=rh.schaefer400_7nets.surfarea.area)
#raw surface area in mm2
n90_parcel_SA_data <- left_join(main_unique,lh, by= "ID")
n90_parcel_SA_data <- left_join(n90_parcel_SA_data,rh, by= "ID")

#plot mean whole-brain with age
parcel_SA_pvals<- lapply(names(n90_parcel_SA_data[,793:1194]), function(x) { summary(lm(as.formula(paste0(x,"~age_scan+male")), data=n90_parcel_SA_data))$coef[2,4]})
parcel_SA_pvals <- unlist(parcel_SA_pvals)
parcel_SA_pvals_fdr <- cbind(parcel_SA_pvals,p.adjust(parcel_SA_pvals,method = "fdr"))
#get age betas
parcel_SA_betas<- lapply(names(n90_parcel_SA_data[,793:1194]), function(x) { lm.beta(lm(as.formula(paste0(x,"~age_scan+male")), data=n90_parcel_SA_data))$standardized.coefficients[[2]]})
parcel_SA_betas <- unlist(parcel_SA_betas)

#save for reloading in future
save(parcel_SA_pvals, parcel_SA_betas, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcel_SA_age_n90.Rdata")

num_of_sig_age_edges_lh=as.list(setNames(parcel_SA_pvals[1:201], schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(parcel_SA_pvals[202:402], schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(magma(20,direction=-1));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_pvals_.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot only significant regions
parcel_SA_pvals_thresh <- ifelse(parcel_SA_pvals<0.05,parcel_SA_pvals,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_SA_pvals_thresh[2:201]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_SA_pvals_thresh[203:402]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(magma(20,direction=-1));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_thresh_pvals_.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot betas for significant regions
parcel_SA_betas_thresh <- ifelse(parcel_SA_pvals<0.05,parcel_SA_betas,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_SA_betas_thresh[2:201]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_SA_betas_thresh[203:402]), schaefer_atlas_region_names_rh))
colFn_diverging = colorRampPalette(magma(20,direction=1));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_thresh_betas.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
```

## Run age models with SA

## non-linear parcel SA effects too.

## Is SA related to FC? 

Structure-function relationship. 
In Graham's PNAS paper, they just correlate x with x, find that x.

Also look at diffusion nets?
Hagmann paper back in 2010 in PNAS also found that structure-function coupling was inversely related to age, but only n=15. 

