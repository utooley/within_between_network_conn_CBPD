---
title: "CBPD Parcel-Level Restuls"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(stats)
library(parallel)
library(lm.beta)
library(packrat)
library(summarytools)
library(visreg)
library(mgcv)
library(RLRsim)
library(GGally)
library(stringr)
library(tidyverse)
library(data.table)
library(bigmemory)
library(biglm)
#load the .RDS file
pipeline='nogsr_spkreg_fd0.5dvars1.75_drpvls'
pipeline="nogsr_spkreg_fd1.25dvars2_drpvls"
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)

load(paste0(network_dir,"/CBPD_n92_schaefer400_allruns.Rdata"))
```

```{r brain plotting setup, include=FALSE, echo=FALSE}
library(fsbrain) #this may not work if you're editing the script directly on the cluster...
library(freesurferformats)
#rearrange the order of the brains in the T9 view of fsbrain
source("~/Documents/tools/fsbrain_fix_t9.R")
environment(brainview.t9) <- asNamespace('fsbrain')
assignInNamespace("brainview.t9", brainview.t9, ns = "fsbrain")
subjects_dir = "/Users/utooley/Documents/tools/CBIG/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/FreeSurfer5.3/";
subject_id = 'fsaverage';       # for functions which use one subject only
atlas='Schaefer2018_400Parcels_7Networks_order'

#Get the Schaefer atlas region names
schaefer_atlas_region_names_lh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="lh");
schaefer_atlas_region_names_rh = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,template_subject=subject_id, hemi="rh");

#set output dir for saving images
output_image_directory="~/Documents/projects/in_progress/within_between_network_conn_CBPD/output/figures/brains/"
  
#Set RGL defaults, larger window and how to make snapshots!
rgloptions=list("windowRect"=c(50,50,1000,1000));
```
## Load data
```{r load parcel data, include=FALSE, echo=FALSE}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#make a huge dataframe of subjects x edges
#STOPPED HERE--NEED TO MAKE THIS!
files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
vect <- matrix(nrow = dim(main_unique)[1], ncol = 79801)
for (i in 1:dim(main_unique)[1]){
mat <- data.frame(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
vect[i,2:79801]<-mat[lower.tri(mat)] #read out the lower triangle from matrix by row
}

#code to read back into a 400 x 400 matrix! This works correctly.
vec<- mat[lower.tri(mat)]
goback <- matrix(nrow = 400, ncol=400)
goback[lower.tri(goback, diag=FALSE)] <- vec
goback <- t(goback)
goback

saveRDS(vect,"~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n92_all_edges.Rdata")

#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
```

## Run edgwise linear models
Run linear models on edges, controlling for age, sex and average motion.
```{r edgewise linear models}
# edgewise_age_pvals<- apply(n90_all_edges,2, function(x) { summary(lm(x~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$pctVolsCensored+main_unique$totalSizet))$coef[2,4]}) #without multicore

#multi-core apply the linear model across the matrix of edges, get age pvals 
# edgewise_age_pvals<- mclapply(1:79800, function(x) { summary(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$totalSizet))$coef[2,4]}, mc.cores = 4)
# edgewise_age_pvals <- unlist(edgewise_age_pvals)
# edgewise_age_pvals_fdr <- cbind(edgewise_age_pvals,p.adjust(edgewise_age_pvals,method = "fdr"))
# #get age betas
# edgewise_age_betas<- mclapply(1:79800, function(x) { lm.beta(lm(n90_all_edges[,x]~main_unique$age_scan+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$totalSizet))$standardized.coefficients[[2]]}, mc.cores = 4)
# edgewise_age_betas <- unlist(edgewise_age_betas)
#save for reloading in future
#save(edgewise_age_pvals_fdr, edgewise_age_betas,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects_all_cov.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects_all_cov.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]
edge_age_betas_mat <- matrix(nrow = 400, ncol=400)
edge_age_betas_mat[lower.tri(edge_age_betas_mat, diag=FALSE)] <- edgewise_age_betas
edge_age_betas_mat[upper.tri( edge_age_betas_mat)] <- t(edge_age_betas_mat)[upper.tri( edge_age_betas_mat)]
```

## Make a chord diagram of pvals and betas

```{r chord diagram of edges, include=FALSE, echo=FALSE}
library(circlize)
library(car)
library(dplyr)
#read in node identity and order
community_assign <- read.delim("~/Documents/tools/parcellations/schaefer400x7CommunityAffiliation.1D", header = F)
communities <- paste0("comm",community_assign$V1) %>% car::recode(.,"'comm1'='Visual'; 'comm2'='Somatomotor' ; 'comm3'='Dorsal Attention';'comm4'='Ventral Attention';'comm5'='Limbic';'comm6'='Frontoparietal';'comm7'='Default'")
community_colors <- communities %>% car::recode(.,"'Visual'='#7B287E'; 'Somatomotor'='#5CA1C8' ; 'Dorsal Attention'='#0A9045';'Ventral Attention'='#C33AF8';'Limbic'='#dcf8a4';'Frontoparietal'='#EF9C23';'Default'='#E34A53'")

#just threshold the betas
links_to_show=edge_age_pvals_mat<= 0.01;edge_age_betas_mat[links_to_show==FALSE] <- 0
#how stringently you threshold determines when you hit the memory limit, 400x400 won't show at 0.005.
col_fun = colorRamp2(breaks = c(-0.48,-0.25,0,0.25,0.5),
                  colors = c("blue", "white","white","white","red"),
                  transparency = .5)
#Original chord diagram
rownames(edge_age_betas_mat) <- communities;colnames(edge_age_betas_mat) <- communities
par(cex = 1.5)
chordDiagramFromMatrix(edge_age_betas_mat[1:200,1:200], annotationTrack = c("name","grid"),
             symmetric = TRUE, grid.col = c("#7B287E", "#5CA1C8", "#0A9045","#C33AF8","#dcf8a4", "#EF9C23", "#E34A53"), col=col_fun, reduce = -1) #reduce keeps even the tiny grids, keeps from eliminating some sectors, annotationTrack turns off the tick marks

#Diagrams trying to keep sectors (regions in this case) in order of region
#make the sector names vertical
rownames(edge_age_betas_mat) <- paste0("region", rep(1:400));colnames(edge_age_betas_mat) <- paste0("region", rep(1:400))
chordDiagramFromMatrix(edge_age_betas_mat[1:200,1:200], annotationTrack = c("grid"), preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(edge_age_betas_mat[1:200,1:200]))))), 
             symmetric = TRUE, grid.col = community_colors[1:200], col=col_fun, reduce = -1)

#try ordering the sectors--this works!
chordDiagramFromMatrix(edge_age_betas_mat[1:200,1:200], annotationTrack = c("grid"), preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(edge_age_betas_mat[1:200,1:200]))))), order=rownames(edge_age_betas_mat[1:200,1:200]),
             symmetric = TRUE, col=col_fun, reduce = -1)

#using grouped chord diagram--this is it!
rownames(edge_age_betas_mat) <- paste0("region", rep(1:400));colnames(edge_age_betas_mat) <- paste0("region", rep(1:400))
group = structure(communities[1:400], names = rownames(edge_age_betas_mat[1:400,1:400]))
group = factor(group, levels = c("Visual","Somatomotor","Dorsal Attention","Ventral Attention", "Limbic","Frontoparietal","Default"))#make it a factor with levels in the order I want to see them
group.col=structure(community_colors[1:400],
                names = rownames(edge_age_betas_mat[1:400,1:400]))
chordDiagramFromMatrix(edge_age_betas_mat[1:400,1:400], annotationTrack = c("grid"), preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(edge_age_betas_mat[1:400,1:400]))))), order=rownames(edge_age_betas_mat[1:400,1:400]),
             symmetric = TRUE, col=col_fun, reduce = -1, group=group, grid.col = group.col, small.gap = 0, big.gap = 5)

#this adds vertical labels to check region order
# we go back to the first track and customize sector labels
circos.track(track.index = 1, panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, 
        facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA) # here set bg.border to NA is important

#take out the vertical labels
chordDiagramFromMatrix(edge_age_betas_mat[1:400,1:400], annotationTrack = c("grid"),  order=rownames(edge_age_betas_mat[1:400,1:400]),
             symmetric = TRUE, col=col_fun, reduce = -1, group=group, grid.col = group.col, small.gap = 0, big.gap = 5)
```

## Plot parcelwise on brain at different sig thresholds

```{r get nodes to plot, include=FALSE, echo=FALSE}
#code to read back into a 400 x 400 matrix! This works correctly.
# vec<- mat[lower.tri(mat)]
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
#copy lower triangle to upper triangle
edge_age_pvals_mat <- t(edge_age_pvals_mat)
#edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)] for a symmetric matrix
```

## Plot pvals on brain.

```{r brain plotting initial, include=FALSE, echo=FALSE}
#Use different pval thresholds and plot parcels that have age-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
print(max(values))
#values <- values/2 #because we indexed the full matrix, there are duplicates for each edge
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","blue"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#Show with the community colors
#Create a list from the vector of Schaefer structure names and the labels from WSBM consensus partition
comms_and_edges=ifelse(values==0,community_assign$V1,-values) #where there are sig age effects, overwrite community color assignment
num_of_sig_age_edges_lh=as.list(setNames(c(0, comms_and_edges[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, comms_and_edges[201:400]), schaefer_atlas_region_names_rh))

#plot with colors of communities
yeo_colors=colorRampPalette(c("#000000","#A9A9A9", "#7B287E", "#5CA1C8", "#0A9045","#C33AF8", "#dcf8a4", "#EF9C23", "#E34A53"))
makecmap_options=list('colFn'=yeo_colors)

rgloptions=list("windowRect"=c(50,50,1000,1000));
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_pvals_", pvalue,"community_colors.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
#just plot schaefer communities
rglactions=list("snapshot_png"=paste0(output_image_directory,"community_colors.png"))
vis.subject.annot(subjects_dir, 'fsaverage6','Schaefer2018_400Parcels_7Networks_order','both', "inflated", views="t4",
                  rgloptions = rgloptions,rglactions = rglactions)
```

## Plot specific communities age-significant edges

```{r specific communities age-significant edges, include=FALSE, echo=FALSE}
#take each set of communities 
community_assign <- read.delim("~/Documents/tools/parcellations/schaefer400x7CommunityAffiliation.1D", header = F)
communities <- paste0("comm",community_assign$V1) %>% car::recode(.,"'comm1'='Visual'; 'comm2'='Somatomotor' ; 'comm3'='Dorsal Attention';'comm4'='Ventral Attention';'comm5'='Limbic';'comm6'='Frontoparietal';'comm7'='Default'")
edge_age_pvals_mat;edge_age_betas_mat
#threshold the betas to only keep those at p < 0.01
pvalue=0.001
links_to_show=edge_age_pvals_mat<= pvalue;edge_age_betas_mat[links_to_show==FALSE] <- 0

rownames(edge_age_betas_mat) <- communities;colnames(edge_age_betas_mat) <- communities
#for all possible combinations of communities
combinations=combn(unique(communities),2)
set=combinations[,1]#take vis and sm community
#do the max
for (j in 1:dim(combinations)[2]){
  set=combinations[,j]
  #take the rows from vis and the columns from SM (and vice-versa?)
  #View(edge_age_betas_mat[rownames(edge_age_betas_mat)==set[1],colnames(edge_age_betas_mat)==set[2]])
  #rows <- which(rownames(edge_age_betas_mat)==set[1], arr.ind = T);cols <- which(colnames(edge_age_betas_mat)==set[2], arr.ind = T)
  colmax=rep(0,400)
  rowmax=rep(0,400)
  indices=which(rownames(edge_age_betas_mat)==set[1])
  for (x in indices){
      rowmax[x] <- max(edge_age_betas_mat[x,which(colnames(edge_age_betas_mat)==set[2])], na.rm = T)
  }
  indices=which(colnames(edge_age_betas_mat)==set[2])
  for (x in indices){
      colmax[x] <- max(edge_age_betas_mat[rownames(edge_age_betas_mat)==set[1],x], na.rm = T)
  }
  #Plot only in one community at a time
  for (community in set){
    values=colmax+rowmax  #these two vectors should be non-overlapping, for the combinations of communities, so can add them together
    print(community)
  values=ifelse(communities==community,values,0)
  pos_sig_age_betas_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
  pos_sig_age_betas_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
  #colormap
  colFn_diverging = colorRampPalette(c("white","white","orange","red"));makecmap_options=list('colFn'=colFn_diverging)
  rglactions=list("snapshot_png"=paste0(output_image_directory,"/pairwise_comm_age_connectivity/max_sig_pos_age_betas_for_parcel_",set[1],set[2],"_regions_in_",community,"_",pvalue,".png"))
  vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  pos_sig_age_betas_lh, 
                               pos_sig_age_betas_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
  }
}
#do the min
for (j in 1:dim(combinations)[2]){
  set=combinations[,j]
  #take the rows from vis and the columns from SM (and vice-versa?)
  #View(edge_age_betas_mat[rownames(edge_age_betas_mat)==set[1],colnames(edge_age_betas_mat)==set[2]])
  #rows <- which(rownames(edge_age_betas_mat)==set[1], arr.ind = T);cols <- which(colnames(edge_age_betas_mat)==set[2], arr.ind = T)
  colmax=rep(0,400)
  rowmax=rep(0,400)
  indices=which(rownames(edge_age_betas_mat)==set[1])
  for (x in indices){
      rowmax[x] <- min(edge_age_betas_mat[x,which(colnames(edge_age_betas_mat)==set[2])], na.rm = T)
  }
  indices=which(colnames(edge_age_betas_mat)==set[2])
  for (x in indices){
      colmax[x] <- min(edge_age_betas_mat[rownames(edge_age_betas_mat)==set[1],x], na.rm = T)
  }
  #Plot only in one community at a time
  for (community in set){
    values=colmax+rowmax  #these two vectors should be non-overlapping, for the combinations of communities, so can add them together
    print(community)
  values=ifelse(communities==community,values,0)
  pos_sig_age_betas_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
  pos_sig_age_betas_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
  #colormap
  colFn_diverging = colorRampPalette(c("blue","lightblue","white","white"));makecmap_options=list('colFn'=colFn_diverging)
  rglactions=list("snapshot_png"=paste0(output_image_directory,"/pairwise_comm_age_connectivity/min_sig_neg_age_betas_for_parcel_",set[1],set[2],"_regions_in",community,"_",pvalue,".png"))
  vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  pos_sig_age_betas_lh, 
                               pos_sig_age_betas_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
  }
}

#Do with the within-community edges
combinations=rbind(unique(communities),unique(communities))
#do the max
for (j in 1:dim(combinations)[2]){
  set=combinations[,j]
  rowmax=rep(0,400)
  indices=which(rownames(edge_age_betas_mat)==set[1])
  for (x in indices){
      rowmax[x] <- max(edge_age_betas_mat[x,which(colnames(edge_age_betas_mat)==set[2])], na.rm = T)
  }
  pos_sig_age_betas_lh=as.list(setNames(c(0, rowmax[1:200]), schaefer_atlas_region_names_lh))
  pos_sig_age_betas_rh=as.list(setNames(c(0, rowmax[201:400]), schaefer_atlas_region_names_rh))
  #colormap
  colFn_diverging = colorRampPalette(c("white","white","orange","red"));makecmap_options=list('colFn'=colFn_diverging)
  rglactions=list("snapshot_png"=paste0(output_image_directory,"max_sig_pos_age_betas_for_parcel_",set[1],set[2],"_regions_",pvalue,".png"))
  vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  pos_sig_age_betas_lh, 
                               pos_sig_age_betas_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}
#do the min
for (j in 1:dim(combinations)[2]){
  set=combinations[,j]
  rowmax=rep(0,400)
  indices=which(rownames(edge_age_betas_mat)==set[1])
  for (x in indices){
      rowmax[x] <- min(edge_age_betas_mat[x,which(colnames(edge_age_betas_mat)==set[2])], na.rm = T)
  }
  pos_sig_age_betas_lh=as.list(setNames(c(0, rowmax[1:200]), schaefer_atlas_region_names_lh))
  pos_sig_age_betas_rh=as.list(setNames(c(0, rowmax[201:400]), schaefer_atlas_region_names_rh))
  #colormap
  colFn_diverging = colorRampPalette(c("blue","lightblue","white","white"));makecmap_options=list('colFn'=colFn_diverging)
  rglactions=list("snapshot_png"=paste0(output_image_directory,"min_sig_neg_age_betas_for_parcel_",set[1],set[2],"_regions_",pvalue,".png"))
  vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  pos_sig_age_betas_lh, 
                               pos_sig_age_betas_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}
```

## Non-linear effects across edges

Where are there non-linear effects of age, if anywhere.
```{r edgewise gam models}
library(mgcv)
library(RLRsim)
library(parallel)
#Read back in the matrix of edges, so you don't create every time.
n90_all_edges<- readRDS("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_all_edges.Rds");n90_all_edges <- n90_all_edges[,-1]
#read back in subject data
pipeline='gsr_spkreg_fd0.5dvars1.75_drpvls'
network_dir=paste0("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline)
load(paste0(network_dir,"/CBPD_n90_schaefer400_allruns.Rdata"))

#multi-core apply the exactRLRT test for non-linear model across the matrix of edges, get age non-lin pvals 
edgewise_age_nonlin_pvals<- mclapply(1:79800, function(x) {exactRLRT(gamm(n90_all_edges[,x]~s(main_unique$age_scan)+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$totalSizet, method = "REML")$lme)$p.value}, mc.cores = 4)
edgewise_age_nonlin_pvals <- unlist(edgewise_age_nonlin_pvals)
#save for reloading in future
save(edgewise_age_nonlin_pvals,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_nonlin_pvals.Rdata")

#code to read back into a 400 x 400 matrix! This works correctly.
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_nonlin_pvals #take uncorrected p-values for now
#copy lower triangle to upper triangle
#edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh--indices gives duplicates!
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
num_of_sig_age_edges_lh=as.list(setNames(c(0, values[1:200]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(0, values[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(c("white","orange", "red"));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"age_nonlin_pvals_", pvalue,"regions.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
}

#What do these edges look like pattern-wise?
sum(edgewise_age_nonlin_pvals<0.05)/length(edgewise_age_nonlin_pvals) #percentage
which(edgewise_age_nonlin_pvals<0.00001)
#make a big plot of them
par(mfrow=c(5,5))
lapply(which(edgewise_age_nonlin_pvals<0.00001), function(x) {plot(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$totalSizet, method = "REML"), residuals=T);summary(gam(n90_all_edges[,x]~s(main_unique$age_scan, k=3)+main_unique$male+main_unique$fd_mean_avg+main_unique$avgweight+main_unique$totalSizet, method = "REML"))})
```

## Are these long or short-distance edges?

First, need to compute the distance matrix for Schaefer400 (distances between centroids), then could sort out significant edges based on distance.

## Compare cosine similarity across significance levels for nodes

Need to use Rick's Matlab code to make null models. Or use some kind of null model--maybe first just use different random pairs of parcels.

Also--would do this on the average matrix (Do I already have this on the cluster? If not, make it), and not the subject matrices? Seems like so.
For a given significance level, take the sig parcels and compute cosine similarity between pairs of connectivity profiles->mean or distribution
Then, compare that to consine similarity between those same pairs of parcels but on randomized null networks generated using Rick's code, or to random pairs of parcels as a less stringent test.
```{r make average FC matrix}
edges_dir=paste0("/cbica/home/tooleyu/projects/in_progress/within_between_network_conn_CBPD/data/imageData/",pipeline,"/schaefer400zNetworks_avg/")
#get adj matrix files
files <- data.frame(list.files(edges_dir)) %>% filter( list.files.edges_dir. %in% paste0(main_unique$ID, "_schaefer400MNI_zavgnetwork.txt")); files$list.files.edges_dir. <- paste0(edges_dir,files$list.files.edges_dir.)
#make an average matrix
summed=matrix(0,400,400)
for (i in 1:dim(main_unique)[1]){
mat <- as.matrix(read_csv(file =paste0(edges_dir,main_unique$ID[i], "_schaefer400MNI_zavgnetwork.txt"), col_names = F))
summed<- summed+mat
}
average <- summed/dim(main_unique)[1]
#save for reloading in future
write.csv(average,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv", row.names = F)
```

Note: rewrote this code in mid-May to do the analysis separating out the edges with positive age effects from the edges with negative age effects and computing their similarity separately.

```{r cosine similarity between significant age nodes, first with all edges, then only significant edges}
library(lsa) #for cosine similarity
#read in average matrix
average_FC_mat <- as.matrix(read.csv("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/n90_average_zscored_FC_matrix.csv"))
#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects_all_cov.Rdata")
#make a matrix
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400);edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
edge_age_pvals_mat[upper.tri(edge_age_pvals_mat)] <- t(edge_age_pvals_mat)[upper.tri(edge_age_pvals_mat)]
#put betas in matrix
edge_age_betas_mat <- matrix(nrow = 400, ncol=400);edge_age_betas_mat[lower.tri(edge_age_betas_mat, diag=FALSE)] <- edgewise_age_betas #take uncorrected p-values for now
edge_age_betas_mat[upper.tri(edge_age_betas_mat)] <- t(edge_age_betas_mat)[upper.tri(edge_age_betas_mat)]

#Use different pval thresholds and plot parcels that have age-nonlin-sig edges at that threshold
pos_edges <- edge_age_pvals_mat;pos_edges[edge_age_betas_mat<0] <- NA
neg_edges <- edge_age_pvals_mat;neg_edges[edge_age_betas_mat>0] <- NA
#separate into edges that have positive sig age effects and edges that have negative
sig_parcel_cosine=vector()
#skip 0.01 for now, because it's really big
pvalues=c(0.01, 0.001,0.0001,0.00001)
for (pvalue in pvalues){
  #i=1
  sig_parcel_cosine=vector()
indices <- which(pos_edges<pvalue, arr.ind = T) #indices of edges that have age effects below a pval
for (x in 1:dim(indices)[1]){
  #for (y in indices[,2]){
    sig_parcel_cosine[x] <- cosine(average_FC_mat[,indices[x,1]], average_FC_mat[,indices[x,2]])#take both columns
    #i <- i+1
  #}
}
assign(paste0("sig_parcel_",pvalue,"cosine"), sig_parcel_cosine[sig_parcel_cosine!=1]) #each cosine value has a duplicate?
}
sig_parcel_edges_only_0.01cosine <- sig_parcel_0.01cosine
sig_parcel_edges_only_0.001cosine <- sig_parcel_0.001cosine
sig_parcel_edges_only_0.0001cosine <- `sig_parcel_1e-04cosine`
sig_parcel_edges_only_0.00001cosine <- `sig_parcel_1e-05cosine`
save(sig_parcel_edges_only_0.001cosine, sig_parcel_edges_only_0.0001cosine, sig_parcel_edges_only_0.00001cosine, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_edges_only_data.Rdata")
load(file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_data.Rdata")

null_parcel_cosine=vector()
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
  i=1
  null_parcel_cosine=vector()
indices <- which(pos_edges<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
indices[,1] <- sample(1:400,dim(indices)[1], replace = T)#replace with random integers 1-400
indices[,2] <- sample(1:400,dim(indices)[1], replace = T)#replace with random integers 1-400
for (x in 1:dim(indices)[1]){
  #for (y in indices[,2]){
    #null_parcel_cosine[i] <- print(cosine(average_FC_mat[,x], average_FC_mat[,y]))#take both columns
    null_parcel_cosine[x] <- cosine(average_FC_mat[,indices[x,1]], average_FC_mat[,indices[x,2]])
    #i <- i+1
  #}
}
assign(paste0("null_parcel_",pvalue,"cosine"), null_parcel_cosine[null_parcel_cosine!=1]) #each cosine value has a duplicate?
}
null_parcel_edges_only_0.01cosine <- null_parcel_0.01cosine
null_parcel_edges_only_0.001cosine <- null_parcel_0.001cosine
null_parcel_edges_only_0.0001cosine <- `null_parcel_1e-04cosine`
null_parcel_edges_only_0.00001cosine <- `null_parcel_1e-05cosine`
save(null_parcel_edges_only_0.001cosine, null_parcel_edges_only_0.0001cosine, null_parcel_edges_only_0.00001cosine, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/cosine_similarity_null_edges_only_data.Rdata")

#plot the difference
pvalues=c("0.01","0.001","0.0001","0.00001")
for (pvalue in pvalues){
plt <- ggplot() + theme_classic()+
  geom_density(aes(x=get(paste0("null_parcel_edges_only_",pvalue,"cosine")), ..count..),fill="purple", alpha=0.2) + 
  geom_density(aes(x=get(paste0("sig_parcel_edges_only_",pvalue,"cosine")),..count..),fill="red", alpha=0.2)+ ggtitle(paste0("Connectivity similarity of parcels w/ pos age FC effects at p <",pvalue)) +
  labs(y= "Number of pairs of parcels", x = "Cosine similarity between parcel connectivity")
print(plt)
print(t.test(get(paste0("sig_parcel_edges_only_",pvalue,"cosine")), get(paste0("null_parcel_edges_only_",pvalue,"cosine"))))
}
```

# Surface Area Models

```{r get average SA for each subject}
library(fsbrain)
library(freesurferformats)
subjects_list <- main_unique$ID
subjects_dir = "/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/"

#get mean thickness and area for these subjects
n90_average_wholebrain_data = group.multimorph.agg.native(subjects_dir, subjects_list, c("thickness", "area"),
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=mean,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_average_wholebrain_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_thickness_SA_n90.Rdata")
#load it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_thickness_SA_n90.Rdata")
#plot mean whole-brain with age
brain_data <- left_join(rename(n90_average_wholebrain_data, ID=subject_id), main_unique, by="ID") %>% mutate(mean_SA=(rh.area+lh.area)/2, mean_CT=(rh.thickness+lh.thickness)/2)
summary(lm(mean_SA~age_scan+male+t1_rating_avg, data=brain_data))
summary(lm(mean_CT~age_scan+male+t1_rating_avg, data=brain_data))
visreg(lm(mean_SA~age_scan+male+t1_rating_avg, data=brain_data), main= "Surface Area")

#get raw SA
n90_total_SA_wholebrain_data = group.multimorph.agg.native(subjects_dir, subjects_list, "area",
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=sum,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_total_SA_wholebrain_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_SA_n90.Rdata")
#save it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_SA_n90.Rdata") 
n90_total_SA_wholebrain_data <- left_join(main_unique, mutate(n90_total_SA_wholebrain_data, total_SA=rh.area+lh.area), by="ID")
summary(lm(total_SA~age_scan+male+t1_rating_avg, data=n90_total_SA_wholebrain_data))
visreg(lm(total_SA~age_scan+male+t1_rating_avg, data=n90_total_SA_wholebrain_data), main= "Total Surface Area")
```

## Run age models with SA

The R function in fsbrain called `group.agg.atlas.native` will get SA within each parcel with an annot file.
However, this function looks like it computes surface area within each parcel itself, based on the annotation file I wrote with mri_surf2surf, meaning that the mri_segstats I ran was not needed. 
These values don't match those generated by mri_segstats, though.

```{r get raw SA age effect within Schaefer400 parcels for each subject}
lh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/schaefer400_lh_surfarea_stats.txt") %>% rename(.,ID=lh.schaefer400_7nets.surfarea.area);rh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids_crosssectional/derivatives/freesurfer/schaefer400_rh_surfarea_stats.txt")%>% rename(.,ID=rh.schaefer400_7nets.surfarea.area)
#raw surface area in mm2
n90_parcel_SA_data <- left_join(main_unique,lh, by= "ID")
n90_parcel_SA_data <- left_join(n90_parcel_SA_data,rh, by= "ID")

#get total SA using this approach
n90_parcel_SA_data$sum_parcel_area <- rowSums(n90_parcel_SA_data[,793:1194])
summary(lm(sum_parcel_area~age_scan+male+t1_rating_avg, data=n90_parcel_SA_data))
visreg(lm(sum_parcel_area~age_scan+male+t1_rating_avg, data=n90_parcel_SA_data), main= "Total Surface Area")
exactRLRT(gamm(sum_parcel_area~s(age_scan)+male+t1_rating_avg, data = n90_parcel_SA_data, method = "REML")$lme)
visreg(gam(sum_parcel_area~s(age_scan)+male+t1_rating_avg, data = n90_parcel_SA_data, method = "REML"), main="Summed total SA")

#plot mean whole-brain with age
parcel_SA_pvals<- lapply(names(n90_parcel_SA_data[,793:1194]), function(x) { summary(lm(as.formula(paste0(x,"~age_scan+male+t1_rating_avg")), data=n90_parcel_SA_data))$coef[2,4]})
parcel_SA_pvals <- unlist(parcel_SA_pvals)
parcel_SA_pvals_fdr <- cbind(parcel_SA_pvals,p.adjust(parcel_SA_pvals,method = "fdr"))
#get age betas
parcel_SA_betas<- lapply(names(n90_parcel_SA_data[,793:1194]), function(x) { lm.beta(lm(as.formula(paste0(x,"~age_scan+male+t1_rating_avg")), data=n90_parcel_SA_data))$standardized.coefficients[[2]]})
parcel_SA_betas <- unlist(parcel_SA_betas)

#save for reloading in future
save(parcel_SA_pvals_fdr, parcel_SA_betas, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcel_SA_age_n90.Rdata")
```

```{r plot parcel-wise age SA effect}
library(viridis)
num_of_sig_age_edges_lh=as.list(setNames(parcel_SA_pvals[1:201], schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(parcel_SA_pvals[202:402], schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(magma(20,direction=-1));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_pvals_.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot only significant regions
parcel_SA_pvals_thresh <- ifelse(parcel_SA_pvals<0.05,parcel_SA_pvals,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_SA_pvals_thresh[2:201]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_SA_pvals_thresh[203:402]), schaefer_atlas_region_names_rh))
#colormap
colormap= colorRampPalette(rev(RColorBrewer::brewer.pal(9, name="OrRd")));makecmap_options=list('colFn'=colormap)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_thresh_pvals_.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot betas for significant regions
parcel_SA_betas_thresh <- ifelse(parcel_SA_pvals<0.05,parcel_SA_betas,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_SA_betas[2:201]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_SA_betas[203:402]), schaefer_atlas_region_names_rh))
colormap= colorRampPalette(rev(RColorBrewer::brewer.pal(9, name="RdBu")));makecmap_options=list('colFn'=colormap)
rglactions=list("snapshot_png"=paste0(output_image_directory,"SA_age_betas.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
```

## Non-linear parcel SA effects too.

```{r parcel-wise gam models for SA}
library(mgcv)
library(RLRsim)

#apply the exactRLRT test for non-linear model across the parcels, get age non-lin pvals 
parcelwise_age_sa_nonlin_pvals<- lapply(names(n90_parcel_SA_data[,793:1194]), function(x) {exactRLRT(gamm(as.formula(paste0(x,"~s(age_scan)+male+t1_rating_avg")), data = n90_parcel_SA_data, method = "REML")$lme)$p.value})
parcelwise_age_sa_nonlin_pvals <- unlist(parcelwise_age_sa_nonlin_pvals)
parcelwise_age_sa_nonlin_pvals <- data.frame(parcelwise_age_sa_nonlin_pvals,names(n90_parcel_SA_data[,793:1194]));colnames(parcelwise_age_sa_nonlin_pvals) <- c("pvalue", "area")
#save for reloading in future
save(parcelwise_age_sa_nonlin_pvals,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcelwise_age_sa_nonlin_pvals.Rdata")

#load back in parcel SA age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcelwise_age_sa_nonlin_pvals.Rdata")

#plot parcels that have age-nonlin-sig SA
parcelwise_age_sa_nonlin_pvals <- ifelse(parcelwise_age_sa_nonlin_pvals$pvalue <0.05,parcelwise_age_sa_nonlin_pvals$pvalue,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA, parcelwise_age_sa_nonlin_pvals[2:201]), schaefer_atlas_region_names_lh))
num_of_sig_age_edges_rh=as.list(setNames(c(NA, parcelwise_age_sa_nonlin_pvals[203:402]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(rev(c("white","orange", "red")));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"parcel_age_nonlin_sa_pvals.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#What do these edges look like pattern-wise? UNUSED
which(parcelwise_age_sa_nonlin_pvals<0.05)
#make a big plot of them
par(mfrow=c(4,5))
lapply(which(parcelwise_age_sa_nonlin_pvals<0.05), function(x) {visreg(gam(as.formula(paste0(names(n90_parcel_SA_data[,793+x]),"~s(age_scan)+male+t1_rating_avg")), method = "REML", data=n90_parcel_SA_data), "age_scan", partial=T)})

```

## Are the edge and SA maps more similar than is expected by chance?
```{r similarity of edge and SA age effects}
library(lsa)
#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects_all_cov.Rdata")
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
edge_age_pvals_mat <- t(edge_age_pvals_mat)#copy lower triangle to upper triangle
#load in parcel SA age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcel_SA_age_n90.Rdata")

#for SA age effect pvalues
pvalues=c(0.01,0.001,0.0001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
#compare
edge_vector=values
SA_vector=parcel_SA_pvals_fdr[-c(1,202),1] #take out the medial wall #parcel_SA_pvals, or thresh of either of these
SA_vector=round(SA_vector,digits = 2)#need to round the pvalues or betas so they are not "singleton", e.g. all different
#SA_vector[is.na(SA_vector)] <- 0
similarity_metric<- cor(edge_vector, SA_vector) #or correlation, cosine similarity, or mahalabonois distance? Other distance metrics?
similarity_metric_perm <- numeric()
#create a null distribution
for (x in 1:10000){
  edge_vector_perm=sample(edge_vector, replace = F)
  SA_vector_perm=sample(SA_vector, replace = F)
  similarity_metric_perm[x] <- cor(edge_vector_perm, SA_vector_perm)
}
p<- ecdf(unlist(similarity_metric_perm))(similarity_metric)
hist(unlist(similarity_metric_perm), main = paste0("Correlation between FC edge age effects and SA pvalues, edge p < ",pvalue), 
     xlab = paste0("p=",p))
abline(v = similarity_metric, col="blue", lwd=3)
}

#for SA age effect betas
pvalues=c(0.01,0.001,0.0001,0.00001)
for (pvalue in pvalues){
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
#compare
edge_vector=values
SA_vector=parcel_SA_betas[-c(1,202)] #take out the medial wall #parcel_SA_pvals, or thresh of either of these
SA_vector=round(SA_vector,digits = 2)#need to round the pvalues or betas so they are not "singleton", e.g. all different
#SA_vector[is.na(SA_vector)] <- 0
similarity_metric<- cor(edge_vector, SA_vector) #or correlation, cosine similarity, or mahalabonois distance? Other distance metrics?
similarity_metric_perm <- numeric()
#create a null distribution
for (x in 1:10000){
  edge_vector_perm=sample(edge_vector, replace = F)
  SA_vector_perm=sample(SA_vector, replace = F)
  similarity_metric_perm[x] <- cosine(edge_vector_perm, SA_vector_perm)
}
p<- ecdf(unlist(similarity_metric_perm))(similarity_metric)
hist(unlist(similarity_metric_perm), main = paste0("Cosine sim between FC edge age effects and SA betas, edge p < ",pvalue), 
     xlab = paste0("p=",p))
abline(v = similarity_metric, col="blue", lwd=3)
}
```

## Spin test of the edge and SA maps

Before running this code block, use the MATLAB function `centroid_extraction_sphere.m` to get the centroid coordinates on the Freesurfer sphere of each of the parcels in the Schaefer400 parcellation. That is needed as input to these functions.

```{r spin test edge and SA age effects}
source("~/Documents/tools/rotate_parcellation/R/rotate.parcellation.R")
source("~/Documents/tools/rotate_parcellation/R/perm.sphere.p.R")
library(matrixStats) #otherwise get rowMins error
#read in centroids of the Schaefer400 parcels
lh_centroids <- as.matrix(read.csv("~/Documents/tools/parcellations/lh.Schaefer400_7Nets_fsaverage6.centroids.csv", header = F));rh_centroids <- as.matrix(read.csv("~/Documents/tools/parcellations/rh.Schaefer400_7Nets_fsaverage6.centroids.csv", header = F))
#SHOULD BE MASKING OUT MEDIAL WALL? Assuming that is first centroid for each
lh_centroids <- lh_centroids[-1,];rh_centroids <- rh_centroids[-1,];

#load back in edge age effects
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/edgewise_age_effects_all_cov.Rdata")
edge_age_pvals_mat <- matrix(nrow = 400, ncol=400)
edge_age_pvals_mat[lower.tri(edge_age_pvals_mat, diag=FALSE)] <- edgewise_age_pvals_fdr[,1] #take uncorrected p-values for now
edge_age_pvals_mat <- t(edge_age_pvals_mat)#copy lower triangle to upper triangle

pvalues=c(0.01,0.001,0.0001)
for (pvalue in pvalues){
  print(pvalue)
indices <- which(edge_age_pvals_mat<pvalue, arr.ind = T) #indices of edges that have age effects  below a pval
l <- data.frame(table(indices)) #for each parcel, how many age-significant edges does it have at a given pval thresh
values <- vector(mode = "double", 400)
for (i in 1:400){
values[as.numeric(as.character(l$indices[i]))] <- l$Freq[i]#replace the indices in values with the num of sig edges from that parcel in the table
}
#maps to compare
edge_vector=values

#other map of SA or CT
parcel_SA_pvals_thresh <- ifelse(parcel_SA_pvals_fdr[,1]<0.05,parcel_SA_pvals_fdr[,1],0)
SA_vector=parcel_SA_pvals_thresh[-c(1,202)]
SA_vector=1-parcel_SA_pvals_fdr[-c(1,202),1] #parcel_SA_pvals uncorrected, or thresholded p-values
#SA_vector=round(SA_vector,2) #need to round?

#rotations<- rotate.parcellation(lh_centroids,rh_centroids,1000)
print(perm.sphere.p(edge_vector,SA_vector, rotations, "pearson"))
}
#save rotations so don't have to do
save(rotations,file= "~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/rotations_schaefer400_fsaverage6_1000x.Rdata")
```

## CT models with edited brains
```{r get CT data}
library(fsbrain)
library(freesurferformats)
not_edited=c("sub-CBPD0054", "sub-CBPD0038","sub-CBPD0068","sub-CBPD0089","sub-CBPD0090","sub-CBPD0097","sub-CBPD0113","sub-CBPD0121")
subjects_list <- main_unique$ID[! main_unique$ID %in% not_edited]
subjects_dir = "/cbica/projects/cbpd_main_data/CBPD_bids/derivatives/freesurfer_edits_t1/"

#get mean thickness for these subjects using fsbrain
n90_averageCT_edited_data = group.multimorph.agg.native(subjects_dir, subjects_list, "thickness",
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=mean,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_averageCT_edited_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_edited_CT_n90.Rdata")
#load it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/mean_edited_CT_n90.Rdata")
#plot mean whole-brain with age
brain_data <- left_join(rename(n90, ID=subject_id), main_unique, by="ID") %>% mutate(mean_CT=(rh.thickness+lh.thickness)/2)
summary(lm(mean_CT~age_scan+male+t1_rating_avg, data=brain_data))
visreg(lm(mean_CT~age_scan+male+t1_rating_avg, data=brain_data), main= "Surface Area")

#get total SA using fsbrain
n90_edited_sum_SA_wholebrain_data = group.multimorph.agg.native(subjects_dir, subjects_list, "area",
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=sum,
     agg_fun_extra_params=list("na.rm"=TRUE));
#save it
save(n90_edited_sum_SA_wholebrain_data, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_edited_SA_n90.Rdata")
#save it
load("~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/total_edited_SA_n90.Rdata") 
n90_total_SA_wholebrain_data <- left_join(main_unique, mutate(n9, total_SA=rh.area+lh.area), by="ID")
summary(lm(total_SA~age_scan+male+t1_rating_avg, data=n90_total_SA_wholebrain_data))
visreg(lm(total_SA~age_scan+male+t1_rating_avg, data=n90_total_SA_wholebrain_data), main= "Total Surface Area")
```

## Run parcel-wise age models with CT

The R function in fsbrain called `group.agg.atlas.native` will get SA within each parcel with an annot file.
However, that function looks gets different values than those generated by mri_segstats, sometimes.

```{r get mean CT age effect within Schaefer400 parcels for each subject}
lh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids/derivatives/freesurfer_edits_t1/schaefer400_lh_thickness_stats.txt") %>% rename(.,ID=Measure.mean) %>% select(-Background.FreeSurfer_Defined_Medial_Wall);rh <- read.delim("/cbica/projects/cbpd_main_data/CBPD_bids/derivatives/freesurfer_edits_t1/schaefer400_rh_thickness_stats.txt")%>% rename(.,ID=Measure.mean)%>% select(-Background.FreeSurfer_Defined_Medial_Wall)
#raw surface area in mm2
n90_parcel_CT_data <- left_join(main_unique,lh, by= "ID")
n90_parcel_CT_data <- left_join(n90_parcel_CT_data,rh, by= "ID")

#get total SA using this approach
n90_parcel_CT_data$mean_parcel_CT <- rowMeans(n90_parcel_CT_data[,793:1192])
summary(lm(mean_parcel_CT~age_scan+male+t1_rating_avg, data=n90_parcel_CT_data))
visreg(lm(mean_parcel_CT~age_scan+male+t1_rating_avg, data=n90_parcel_CT_data), main= "Total CT")
exactRLRT(gamm(mean_parcel_CT~s(age_scan)+male+t1_rating_avg, data = n90_parcel_CT_data, method = "REML")$lme)
visreg(gam(mean_parcel_CT~s(age_scan)+male+t1_rating_avg, data = n90_parcel_CT_data, method = "REML"), main="Summed total SA")

#plot mean whole-brain with age
parcel_CT_pvals<- lapply(names(n90_parcel_CT_data[,793:1192]), function(x) { summary(lm(as.formula(paste0(x,"~age_scan+male+t1_rating_avg")), data=n90_parcel_CT_data))$coef[2,4]})
parcel_CT_pvals <- unlist(parcel_CT_pvals)
parcel_CT_pvals_fdr <- cbind(parcel_CT_pvals,p.adjust(parcel_CT_pvals,method = "fdr"))
#get age betas
parcel_CT_betas<- lapply(names(n90_parcel_CT_data[,793:1192]), function(x) { lm.beta(lm(as.formula(paste0(x,"~age_scan+male+t1_rating_avg")), data=n90_parcel_CT_data))$standardized.coefficients[[2]]})
parcel_CT_betas <- unlist(parcel_CT_betas)

#save for reloading in future
save(parcel_CT_pvals_fdr, parcel_CT_betas, file="~/Documents/projects/in_progress/within_between_network_conn_CBPD/data/imageData/gsr_spkreg_fd0.5dvars1.75_drpvls/parcel_CT_age_n90.Rdata")
```

```{r plot parcel-wise age CT effect}
library(viridis)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_CT_pvals[1:200]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_CT_pvals[201:400]), schaefer_atlas_region_names_rh))
#colormap
colFn_diverging = colorRampPalette(magma(20,direction=-1));makecmap_options=list('colFn'=colFn_diverging)
rglactions=list("snapshot_png"=paste0(output_image_directory,"CT_age_pvals.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot only significant regions
parcel_CT_pvals_thresh <- ifelse(parcel_CT_pvals<0.05,parcel_CT_pvals,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_CT_pvals_thresh[1:200]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_CT_pvals_thresh[201:400]), schaefer_atlas_region_names_rh))
#colormap
colormap= colorRampPalette(rev(RColorBrewer::brewer.pal(9, name="OrRd")));makecmap_options=list('colFn'=colormap)
rglactions=list("snapshot_png"=paste0(output_image_directory,"CT_age_thresh_pvals.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)

#plot betas for significant regions
parcel_CT_betas_thresh <- ifelse(parcel_CT_pvals<0.05,parcel_CT_betas,NA)
num_of_sig_age_edges_lh=as.list(setNames(c(NA,parcel_CT_betas_thresh[1:200]), schaefer_atlas_region_names_lh)) #this has the medial wall in it.
num_of_sig_age_edges_rh=as.list(setNames(c(NA,parcel_CT_betas_thresh[201:400]), schaefer_atlas_region_names_rh))
colormap= colorRampPalette(rev(RColorBrewer::brewer.pal(9, name="RdBu")));makecmap_options=list('colFn'=colormap)
rglactions=list("snapshot_png"=paste0(output_image_directory,"CT_age_thresh_betas.png"))
vis.region.values.on.subject(subjects_dir, 'fsaverage6', 'Schaefer2018_400Parcels_7Networks_order',  num_of_sig_age_edges_lh, 
                             num_of_sig_age_edges_rh, makecmap_options = makecmap_options, "inflated", views="t4", draw_colorbar = T, rgloptions = rgloptions, rglactions = rglactions)
```

## SA models with edited brains

